AIが書いたテックブログ

# Apollo Client の cache.modify は必要か？

結論: **必須ではないが、UIの整合性を保つために必要な場面が多い**。

## Apollo の cache は「クリア」されない

Apollo Client は、**mutation を実行してもキャッシュ全体を自動で消しません**。  
代わりに、**mutation の戻り値をキャッシュに合成（マージ）**して更新します。

ポイント:
- **`id` と `__typename` があるデータは同じものとして上書き・統合される**
- つまり「キャッシュ全消し」ではなく「部分更新」
- **一覧（リスト）は自動更新されないことが多い**ので、必要なら `cache.modify` などで明示的に更新する

本当に全消ししたいときだけ、以下を手動で使います。
- `client.resetStore()`（再フェッチあり）
- `client.clearStore()`（再フェッチなし）

今回のコードでは、`deleteTodo` の結果を受けて **Apolloのキャッシュ上の `todos` 一覧から該当Todoを取り除く** ために `cache.modify` を使っています。

## cache が必要な理由

Apollo Client は取得済みデータをキャッシュし、次回以降の表示に使います。
しかし、削除ミューテーションを実行しても、**キャッシュの一覧は自動で書き換わらない**ことが多いです。
その結果、
- サーバー上では削除済みなのに、UIにまだ残る
という不一致が起きます。

このズレを防ぐために、`cache.modify` で一覧を手動更新します。

## あった方がいい場合（cache を更新すべき）

- **一覧から削除した直後にUIを即座に反映したい**
- **クエリの再取得（refetch）を避けたい**
- **ネットワークを減らして体感速度を上げたい**
- **optimistic UI（先に見た目だけ更新）**をやりたい

こういう場面では、キャッシュ更新を入れるとユーザー体験が良くなります。

## ない方がいい場合（cache を手動でいじらない）

- **キャッシュの更新ロジックが複雑でバグりやすい**
- **削除後に別のクエリで必ず再取得する設計**
- **データ整合性より実装の単純さを優先したい**

この場合は、
- `refetchQueries` を使う
- 画面を再読み込みする
などで割り切ることもあります。

## 実務的な判断基準

- **一覧の一部を削除するだけなら `cache.modify` が最も簡単**
- **影響範囲が広い場合（複数画面/複数クエリにまたがる）なら refetch の方が安全**

## まとめ

- cache 更新は「必要なときだけやる」
- UXを優先するなら `cache.modify`
- 安全・簡潔にしたいなら `refetchQueries`
